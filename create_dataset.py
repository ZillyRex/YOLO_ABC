import os
import random
from PIL import Image, ImageDraw
from tqdm import tqdm
from odutil import analysis
import argparse


def iou(box_1, box_2):
    '''
    Calculate the IOU of two boxes in the shape of (x, y, w, h).
    '''
    inter_xmin = max(box_1[0], box_2[0])
    inter_xmax = min(box_1[0]+box_1[2], box_2[0]+box_2[2])
    inter_ymin = max(box_1[1], box_2[1])
    inter_ymax = min(box_1[1]+box_1[3], box_2[1]+box_2[3])
    if(inter_xmin >= inter_xmax or inter_ymin >= inter_ymax):
        return 0
    inter_area = (inter_xmax-inter_xmin)*(inter_ymax-inter_ymin)
    union_area = (box_1[2])*(box_1[3]) + (box_2[2])*(box_2[3]) - inter_area
    return inter_area/union_area


def is_box_valid(box, boxes, occluded_rate):
    '''
    Check if all the occluded rate between the box and the one in boxes
    is <= occluded_rate. All the boxes are in the shape of (x, y, w, h).
    '''
    for box_pikachu in boxes:
        if iou(box_pikachu, box) > occluded_rate:
            return False
    return True


def create_dataset(img_dir, obj_dir, output_dir, label_dir, N, obj_num_max, obj_size_min, obj_size_max, occluded_rate=0.):
    '''
    Create an dataset and its labels for object detection.
    '''

    # check all the params.
    assert os.path.isdir(img_dir), f'{img_dir} is invalid dir.'
    assert os.path.isdir(obj_dir), f'{obj_dir} is invalid dir.'

    if not os.path.isdir(output_dir):
        os.makedirs(output_dir)
    if not os.path.isdir(label_dir):
        os.makedirs(label_dir)

    assert type(N) is int, 'N is not int.'
    assert N > 0, 'N is non-positive.'

    assert type(obj_num_max) is int, 'obj_num_max is not int.'
    assert obj_num_max > 0, 'obj_num_max is non-positive.'

    assert type(obj_size_min) is float, 'obj_size_min is not float.'
    assert type(obj_size_max) is float, 'obj_size_max is not float.'
    assert 0 < obj_size_min < 1, 'obj_size_min is out of range (0, 1).'
    assert 0 < obj_size_max < 1, 'obj_size_max is out of range (0, 1).'
    assert obj_size_max >= obj_size_min, 'obj_size_max is smaller than obj_size_min.'

    if obj_num_max > 1:
        assert type(occluded_rate) is float, 'occluded_rate is not float.'
        assert 0 < occluded_rate < 1, 'occluded_rate if out of range (0, 1).'

    # get all the original image and object image files and shuffle.
    ori_img_files = os.listdir(img_dir)
    obj_img_files = os.listdir(obj_dir)
    random.shuffle(ori_img_files)
    random.shuffle(obj_img_files)

    # Choise an original image and at most obj_num_max object images
    # then make a target image and label at a time untile num_total reach N.
    num_total = 0
    pbar = tqdm(total=N)
    while num_total < N:
        img_file = random.choice(ori_img_files)
        obj_num = random.randint(1, obj_num_max)
        obj_files = random.sample(obj_img_files, obj_num)

        img = Image.open(os.path.join(img_dir, img_file))
        W, H = img.size
        obj_w_min, obj_w_max = int(obj_size_min*W), int(obj_size_max*W)
        obj_h_min, obj_h_max = int(obj_size_min*H), int(obj_size_max*H)

        boxes = []
        for obj_file in obj_files:
            obj = Image.open(os.path.join(obj_dir, obj_file))
            obj_w = random.randint(obj_w_min, obj_w_max)
            obj_h = random.randint(obj_h_min, obj_h_max)
            paste_x = random.randint(0, W-obj_w)
            paste_y = random.randint(0, H-obj_h)
            box = (paste_x, paste_y, obj_w, obj_h)

            # generate a valid box.
            if boxes:
                while not is_box_valid(box, boxes, occluded_rate):
                    obj_w = random.randint(obj_w_min, obj_w_max)
                    obj_h = random.randint(obj_h_min, obj_h_max)
                    paste_x = random.randint(0, W-obj_w)
                    paste_y = random.randint(0, H-obj_h)
                    box = (paste_x, paste_y, obj_w, obj_h)
                boxes.append(box)
            else:
                boxes.append(box)

            obj = obj.resize((obj_w, obj_h))
            img.paste(obj, (paste_x, paste_y))
        img.save(os.path.join(output_dir, f'{num_total:06d}.jpg'))

        # generate label.
        label_file = os.path.join(label_dir, f'{num_total:06d}.txt')
        with open(label_file, 'w') as f:
            for box in boxes:
                x, y, w, h = box
                line = f'0 {(x+w/2)/W} {(y+h/2)/H} {w/W} {h/H}\n'
                f.write(line)

        num_total += 1
        pbar.update()

    pbar.close()
    print('create done.')


def draw_box(img_dir, label_dir, output_dir):
    '''
    Draw the box generated by create_dataset.
    '''
    assert os.path.isdir(img_dir), f'{img_dir} is invalid dir.'
    assert os.path.isdir(label_dir), f'{label_dir} is invalid dir.'

    if not os.path.isdir(output_dir):
        os.makedirs(output_dir)

    img_files = os.listdir(img_dir)

    for img_file in img_files:
        label_file = os.path.splitext(img_file)[0]+'.txt'
        img = Image.open(os.path.join(img_dir, img_file))
        W, H = img.size
        draw = ImageDraw.Draw(img)
        with open(os.path.join(label_dir, label_file)) as f:
            for line in f:
                _, cx_, cy_, w_, h_ = list(map(float, line.strip().split()))
                x1 = int((cx_-w_/2)*W)
                y1 = int((cy_-h_/2)*H)
                x2 = int((cx_+w_/2)*W)
                y2 = int((cy_+h_/2)*H)
                draw.rectangle([(x1, y1), (x2, y2)],
                               outline=(0, 255, 0),
                               width=2)
        img.save(os.path.join(output_dir, img_file))

    print('drawing done.')


def get_parser():
    parser = argparse.ArgumentParser()
    parser.add_argument('--img_dir', type=str, required=True,
                        help='Original images dir.')
    parser.add_argument('--obj_dir', type=str, required=True,
                        help='Object images dir.')
    parser.add_argument('--output_dir', type=str, required=True,
                        help='Target images output dir.')
    parser.add_argument('--label_dir', type=str, required=True,
                        help='Target labels output dir.')
    parser.add_argument('--N', type=int, required=True,
                        help='Amount of target images.')
    parser.add_argument('--obj_num_max', type=int, required=True,
                        help='Amount of objects in an image at most.')
    parser.add_argument('--obj_size_min', type=float, required=True,
                        help='Min scale of an object')
    parser.add_argument('--obj_size_max', type=float, required=True,
                        help='Max scale of an object')
    parser.add_argument('--occluded_rate', type=float, required=True,
                        help='Objects occluded at most.')
    parser.add_argument('--output_bbox_dir', type=str, required=True,
                        help='Target images with bbox output dir.')
    parser.add_argument('--train_path', type=str, required=True,
                        help='Train subset txt output path.')
    parser.add_argument('--val_path', type=str, required=True,
                        help='Val subset txt output path.')
    parser.add_argument('--train_ratio', type=float, required=True,
                        help='Training set ratio.')

    return parser


def main():
    parser = get_parser()
    args = parser.parse_args()
    create_dataset(args.img_dir,
                   args.obj_dir,
                   args.output_dir,
                   args.label_dir,
                   args.N,
                   args.obj_num_max,
                   args.obj_size_min,
                   args.obj_size_max,
                   args.occluded_rate)

    draw_box(args.output_dir, args.label_dir, args.output_bbox_dir)

    analysis.split_trainval(args.output_dir,
                            args.train_path,
                            args.val_path,
                            args.train_ratio)
    print('split done.')


if __name__ == '__main__':
    main()
